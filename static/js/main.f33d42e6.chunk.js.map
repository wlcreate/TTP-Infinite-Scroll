{"version":3,"sources":["App.js","hooks/useInfiniteScroll.js","index.js"],"names":["App","data","numPinsToGet","useState","pins","setPins","numDisplayedResults","setNumDisplayedResults","observer","useRef","useEffect","firstPins","filter","pin","index","length","repeatedPins","push","numLeftoverPins","leftoverPins","morePins","prevPins","lastPinRef","useCallback","current","disconnect","IntersectionObserver","entries","isIntersecting","prevNumDisplayedResults","threshold","observe","useInfiniteScroll","className","map","ref","src","images","url","alt","pin_join","visual_descriptions","pinner","username","ReactDOM","render","document","getElementById"],"mappings":"2PAkDeA,MA9Cf,WACE,IADa,ECFA,SAA2BC,EAAMC,GAAe,IAAD,EACpCC,mBAAS,IAD2B,mBACrDC,EADqD,KAC/CC,EAD+C,OAENF,mBAAS,GAFH,mBAErDG,EAFqD,KAEhCC,EAFgC,KAGtDC,EAAWC,mBAEjBC,qBAAU,WACR,GAA4B,IAAxBJ,EAA2B,CAC7B,IAAMK,EAAYV,EAAKW,QAAO,SAACC,EAAKC,GAClC,OAAOA,EAAQZ,KAEjBG,EAAQM,QACH,GAAIL,GAAuBL,EAAKc,OAAQ,CAG7C,IAFA,IAAIC,EAAe,GAEZA,EAAaD,OAASd,EAAKc,OAAST,GACzCU,EAAaC,KAAb,MAAAD,EAAY,YAASf,IAGvB,IAAMiB,EAAkBZ,EAAsBU,EAAaD,OACrDI,EAAelB,EAAKW,QAAO,SAACC,EAAKC,GACrC,OAAOA,EAAQI,KAGjBb,EAAQ,GAAD,OAAKW,EAAL,YAAsBG,SACxB,CACL,IAAMC,EAAWnB,EAAKW,QAAO,SAACC,EAAKC,GACjC,OAAOA,EAAQR,GAAuBQ,EAAQV,EAAKW,OAAS,KAG9DV,GAAQ,SAACgB,GAAD,4BAAkBA,GAAlB,YAA+BD,UAExC,CAACd,EAAqBF,EAAKW,OAAQd,EAAMC,IAG5C,IAAMoB,EAAaC,uBACjB,SAACV,GAEKL,EAASgB,SAAShB,EAASgB,QAAQC,aAEvCjB,EAASgB,QAAU,IAAIE,sBACrB,SAACC,GACKA,EAAQ,GAAGC,gBACbrB,GACE,SAACsB,GAAD,OACEA,EAA0B3B,OAIlC,CAAE4B,UAAW,IAGXjB,GAAKL,EAASgB,QAAQO,QAAQlB,KAEpC,CAACX,IAGH,MAAO,CAAEE,OAAMkB,cDpDcU,CAAkB/B,EAD1B,IACbG,EAFK,EAELA,KAAMkB,EAFD,EAECA,WAEd,OACE,gCACE,oBAAIW,UAAU,UAAd,kDAEA,oBAAGA,UAAU,aAAb,qCAAmD7B,EAAKW,UAExD,qBAAKkB,UAAU,OAAf,SACG7B,GACCA,EAAK8B,KAAI,SAACrB,EAAKC,GACb,OAAIV,EAAKW,SAAWD,EAAQ,EAExB,sBAAKqB,IAAKb,EAAwBW,UAAU,OAA5C,UACE,qBACEG,IAAKvB,EAAIwB,OAAO,QAAQC,IACxBC,IAAK1B,EAAI2B,SAASC,oBAAoB,GACtCR,UAAU,eAEZ,oBAAGA,UAAU,cAAb,UACE,0CADF,KACwBpB,EAAI6B,OAAOC,cAPV7B,GAa3B,sBAAiBmB,UAAU,OAA3B,UACE,qBACEG,IAAKvB,EAAIwB,OAAO,QAAQC,IACxBC,IAAK1B,EAAI2B,SAASC,oBAAoB,GACtCR,UAAU,eAEZ,oBAAGA,UAAU,cAAb,UACE,0CADF,KACwBpB,EAAI6B,OAAOC,cAP3B7B,YE3B1B8B,IAASC,OAAO,cAAC,EAAD,IAASC,SAASC,eAAe,U","file":"static/js/main.f33d42e6.chunk.js","sourcesContent":["import \"./App.css\";\nimport data from \"./data/nyc_ttp_pins.json\";\nimport useInfiniteScroll from \"./hooks/useInfiniteScroll\";\n\nfunction App() {\n  const numPinsToGet = 12;\n  const { pins, lastPinRef } = useInfiniteScroll(data, numPinsToGet);\n\n  return (\n    <div>\n      <h1 className=\"heading\">üêæ Cat Attack üêæ</h1>\n\n      <p className=\"pin-number\">Current number of pins: {pins.length}</p>\n\n      <div className=\"grid\">\n        {pins &&\n          pins.map((pin, index) => {\n            if (pins.length === index + 1) {\n              return (\n                <div ref={lastPinRef} key={index} className=\"card\">\n                  <img\n                    src={pin.images[\"236x\"].url}\n                    alt={pin.pin_join.visual_descriptions[0]}\n                    className=\"card-image\"\n                  />\n                  <p className=\"card-pinner\">\n                    <span>Pinner</span>: {pin.pinner.username}\n                  </p>\n                </div>\n              );\n            } else {\n              return (\n                <div key={index} className=\"card\">\n                  <img\n                    src={pin.images[\"236x\"].url}\n                    alt={pin.pin_join.visual_descriptions[0]}\n                    className=\"card-image\"\n                  />\n                  <p className=\"card-pinner\">\n                    <span>Pinner</span>: {pin.pinner.username}\n                  </p>\n                </div>\n              );\n            }\n          })}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { useEffect, useState, useRef, useCallback } from \"react\";\n\nexport default function useInfiniteScroll(data, numPinsToGet) {\n  const [pins, setPins] = useState([]);\n  const [numDisplayedResults, setNumDisplayedResults] = useState(0);\n  const observer = useRef();\n\n  useEffect(() => {\n    if (numDisplayedResults === 0) {\n      const firstPins = data.filter((pin, index) => {\n        return index < numPinsToGet;\n      });\n      setPins(firstPins);\n    } else if (numDisplayedResults >= data.length) {\n      let repeatedPins = [];\n\n      while (repeatedPins.length + data.length < numDisplayedResults) {\n        repeatedPins.push(...data);\n      }\n\n      const numLeftoverPins = numDisplayedResults - repeatedPins.length;\n      const leftoverPins = data.filter((pin, index) => {\n        return index < numLeftoverPins;\n      });\n\n      setPins([...repeatedPins, ...leftoverPins]);\n    } else {\n      const morePins = data.filter((pin, index) => {\n        return index < numDisplayedResults && index > pins.length - 1;\n      });\n\n      setPins((prevPins) => [...prevPins, ...morePins]);\n    }\n  }, [numDisplayedResults, pins.length, data, numPinsToGet]);\n\n  // every time a new last pin is created this callback is invoked with a reference to that last pin\n  const lastPinRef = useCallback(\n    (pin) => {\n      // will be null at first so when there is a current ref, disconnect the observer from the previous element so new last element can be connected correctly\n      if (observer.current) observer.current.disconnect();\n\n      observer.current = new IntersectionObserver(\n        (entries) => {\n          if (entries[0].isIntersecting) {\n            setNumDisplayedResults(\n              (prevNumDisplayedResults) =>\n                prevNumDisplayedResults + numPinsToGet\n            );\n          }\n        },\n        { threshold: 1.0 }\n      );\n\n      if (pin) observer.current.observe(pin);\n    },\n    [numPinsToGet]\n  );\n\n  return { pins, lastPinRef };\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}